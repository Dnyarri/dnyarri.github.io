<!DOCTYPE html>
<html lang='en-US'>
<head>
    <link rel='icon' href='vaba.svg' type='image/svg+xml'>
    <link rel='author' href='mailto:ilyarazmanov@gmail.com'>
    <link rel='canonical' href='https://dnyarri.github.io/imin.html'/>
    <meta charset='utf-8' />
    <meta name='author' content='Ilyich the Toad'>
    <meta name='description' content='Barycentric and bilinear image interpolation in pure Python'>
    <meta name='keywords' content='Python, barycentric, image, resize'>
    <link rel='stylesheet' href='toc.css' type='text/css'>
    <link rel='stylesheet' href='content.css' type='text/css'>
    <title>Barycentric and bilinear image interpolation in pure Python</title>
</head>
<body>
    <div class='leftarea'> <!-- Nav holder begin -->
        <object data='toc.html' class='leftbar'></object>
    </div>
    <div class='content'> <!-- Content block begin -->
        <h1 class='darkbg'>ImIn (Image interpolation)</h1>
        <h2 class='lightbg'>Barycentric and bilinear image interpolation and transformation in pure Python</h2>
        <div class='lightbg justborder cols2'>
            <h3>Overview</h3>
            <p><a href='https://github.com/Dnyarri/imin' class='git' title='Barycentric and bilinear image interpolation and transformation in pure Python at Github'>ImIn (Image Interpolation)</a> module contains Python code for <a href='https://en.wikipedia.org/wiki/Bilinear_interpolation' target='_blank'>bilinear image interpolation</a> and <a href='https://en.wikipedia.org/wiki/Barycentric_coordinate_system' target='_blank'>barycentric image interpolation</a> in general and rescaling in particular. That is, it contains functions for for reading one pixel at float coordinates, interpolated from real pixels (having integer coordinates), as well as functions for transforming whole image (rescaling, rotating, <i>etc.</i>) using interpolation methods above.</p>
            <p>It is well known that image interpolation authors tend to increase image analysis area size. With bilinear interpolation, pixel is considered as square, and interpolation takes place between four corners. With bicubic interpolation, more neighbour pixels are added to analysis. This is good for smooth gradients but what about some sharp edges? Why not to try using just half a pixel? For example, split a pixel square ■ diagonally into two triangles like ◤◢ or ◣◥, and use analysis within one half of a pixel using three corners?</p>
            <p>Since I appeared to be unable to find such a triangular interpolation in any big programs like Photoshop or GIMP, I decided to write corresponding algorithm myself and see how it works.</p>
            <p>It appears that the best coordinate system for triangles is <a href='https://en.wikipedia.org/wiki/Barycentric_coordinate_system'>barycentric coordinate system</a>, which is widely used in science, in 3D graphics, sometimes used in 2D vector gradients, but, for unclear reasons, not used in regular 2D image processing.</p>
            <p>So, I wrote my own barycentric interpolation code, and, after a long debugging of simple school math, it appeared to give rather interesting results when used for image rescaling, so I even tend to prefer using it for my images in some cases, regardless of the fact that Python code is always slower than optimized machine code in Photoshop.</p>
            <p>At the same time I got bored by copying my own code for bilinear image interpolation from one program to another (yes, there is an interpolation in, say, <a href='pov3zaika.html'>POV-Ray 6³&nbsp;Mosaic</a> or <a href='img2mesh.html'>img2mesh</a>).</p>
            <p>So, I decided to join my code for bilinear and barycentric image interpolation in some sort of a single module, which can be easily plugged into different image processing Python programs. So, here it goes.</p>
            <p>Ladies and gentlemen! <span lang='fr'>Mesdames et messieurs!</span> <span lang='ru-Cyrl'>Товарищи и товарищи!</span> Let me introduce to you the one and only <a href='https://github.com/Dnyarri/imin' class='git' title='Barycentric and bilinear image interpolation and transformation in pure Python at Github'>Image Interpolation (imin) module</a>, combining simple yet carefully designed and even somewhat optimized bilinear and barycentric image interpolation in pure Python!</p>
        </div>
        <div class='lightbg justborder cols2'>
            <h3>Module and example programs</h3>
            <p>Currently default branch is <a href='https://github.com/Dnyarri/imin/tree/functional' class='git' title='Barycentric and bilinear image interpolation and transformation in pure Python at Github, functional version'>"Functional"</a>, bearing this name because it is supposed to be used as functions, not a class. Corresponding class equivalent is under development, and supposed to be published later.</p>
            <p>Module content is briefly summarized below.</p>
            <ul>
                <li><b><span class='pre'>__init__.py</span></b>: This is not just an init file. Actually, it contains all code required to read image pixel at float coordinates, interpolated from surrounding pixels using either barycentric or bilinear method. If reading image pixels is all you need, you may copy __init__.py file alone and use it for your applications. Remember that I don't give a care to legal stuff, so you can use my code for free, completely or partially, and modify at will.</li>
                <li><b><span class='pre'>displace.py</span></b>: General purpose image displacement using either barycentric or bilinear interpolation. Exact type of displacement is controlled by fx(x, y) and fy(x, y) functions, given to displace as arguments.</li>
                <li><b><span class='pre'>rescale.py</span></b>: Image rescaling. Obviously, image rescaling is a specific case of displacement, and can be done with displacer, but specific case of rescaling gives a chance to add some specific speed optimization; therefore a separate code was created.</li>
            </ul>
            <p>Detailed functions description and parameters for developers are given in a rather prolific docstrings.</p>
            <p>Surely, during development module needs testing. Therefore some GUI shell programs were created for testing and illustration purposes:</p>
            <ul>
                <li><b><span class='pre'>distorter.py</span></b>: the main part of demo. Distorter provides examples of general purpose image displacer (<span class='pre'>displace.py</span> above) usage. Currently demo includes only two functions: linear skewing and wave-like deformation with sine function;</li>
                <li><b><span class='pre'>mdbiggener.py</span></b>: image rescaler; provides a demo for <span class='pre'>rescale.py</span>;</li>
                <li><b><span class='pre'>revolver.py</span></b>: image rotation program. Based entirely on <span class='pre'>displace.py</span>, and separated as specific program just because rotation GUI should take only one argument (i.e. angle), while displacement currently takes two (one for x and other for y). To avoid making a general program with only half of GUI being functional, this particular example program was created.</li>
            </ul>
        </div>
        <br>
        <div class='lightbg justborder'>
        <p>Now it's time to either step forward to <a href='https://github.com/Dnyarri/imin' class='git' title='Barycentric and Bilinear Image Interpolation repository at GitHub'>Image Interpolation repository at GitHub</a> for downloads...</p>
        <p class='right'>...or Move back to <a href='https://dnyarri.github.io' title='Python freeware for POV-Ray and other 3D, Scale2x, Scale3x, Scale2xSFX, Scale2xSFX, PPM and PGM image support, bilinear and barycentric image interpolation, and batch processing'>Dnyarri`s Python freeware main page</a>.</p>
        </div>
    </div> <!-- Content block end -->
</body>
</html>